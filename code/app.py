from flask import Flask, request
from flask_restful import Resource, Api
# Resource is just a thing that our API can return and create.
# Resource are usually mapped into database tables as well,

app = Flask(__name__)
# flask is going to be our app and our app is gonna have all these routes
# as we saw in the last section 
# and then we can create new routes
# and assign methods to them and things like that.

# And we're gonna create something else which is gonna be the API.
# And the API as you can see is imported from flask_restful
# and that's just going to allow us to very easily add these resources to it.
api = Api(app)
# for this resource you can get, put, post, and delete and so on.

#we're going to use an in-memory database,w hich is just a Python list
items = []

# The API works with resources and every resource has to be a class.
#  class student then inherits from the class resource.
class Item(Resource):
    def get(self, name):
        #  for item in items:
        #     if item['name'] == name:
        #         return item
        # we're going to filter the list of items that is our in memory database.
        # and then we're going to write a lambda function for what we're going to filter by.

        # item = filter(lambda x: x['name'] == name, items)
            # So the filter function takes two arguments.
            # First a filtering function
            # and then the list of items that we're filtering.
            # We're going to go through each item, execute this function and
            # see if the item's name x matches the name which is the parameter.
            # And if it does, then we're gonna return it.

            # The filter function doesn't return an item.
            # Potentially there could be many items generated by this filter function.
            # So it cannot possibly return a single one.

        # However it also doesn't return a list. 
        # It returns a filter object and a filter object is an object that you can call a couple of methods on,
        # such as list.
        # item = list(filter(lambda x: x['name'] == name, items))

        # So instead of list, which gives us a list of items and that would give us a list of a single item,
        # we can use next and that gives us the first item found by this filter function.
        # but we can call next again if there are more items and that would give us the
        # second item and then the third item and so on.
        # item = next(filter(lambda x: x['name'] == name, items))

        # And also do remember, next can raise an error and it can break our programme
        # if there are no items left.
        # It would break because there are no items that match the name.
        item = next(filter(lambda x: x['name'] == name, items), None)
        # return {'item': item}, 200 if item is not None else 404
        return {'item': item}, 200 if item else 404
 
    def post(self, name):
        # Now we've decided that we're normally only gonna have unique names for items,
        # so let's ensure that.
        # if next(filter(lambda x: x['name'] == name, items), None) is not None:
        if next(filter(lambda x: x['name'] == name, items), None):            
            return {'message': "An item with name '{}' already exists.".format()}, 400
            # 400 is bad request

        # it means there is an item that matches the name. 
        # And if there is, we don't want to create a new item.
        # All we want to do is return.

        data = request.get_json(silent=True)
        item = {'name': name, 'price': data['price']}
        items.append(item)
        return item, 201


class ItemList(Resource):
    def get(self):
        return {'items': items}


# tell our API, okay , This resource that we've created, the student,
# now is gonna be accessible via our API,
api.add_resource(Item, '/item/<string:name>')

# Don't forget to add the resource item list, and make sure to give it the correct endpoint,
api.add_resource(ItemList, '/items')

# finally app.run and port=5000, this is not necessary, that's the default
app.run(port=5000, debug=True)


